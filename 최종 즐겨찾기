import os
import random
import joblib
import numpy as np
from typing import List
from fastapi import FastAPI, Header, HTTPException, Request 
from pydantic import BaseModel
from sentence_transformers import SentenceTransformer, util

# === Firebase Admin SDK ===
import firebase_admin
from firebase_admin import credentials, firestore

# API í‚¤ ìƒìˆ˜
API_KEY = "twenty-clothes-api-key"

# === Firebase ì´ˆê¸°í™” ===
cred = credentials.Certificate("xxxx") 
firebase_admin.initialize_app(cred)
db = firestore.client()  # Firestore DB í´ë¼ì´ì–¸íŠ¸

# === FastAPI ì•± ì´ˆê¸°í™” ===
app = FastAPI()

# === Sentence-BERT ëª¨ë¸ ë¡œë”© (ì˜ìƒ ì´ë¦„ì„ ë²¡í„°ë¡œ ì„ë² ë”©) ===
model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')

# === ê²½ë¡œ ì„¤ì • (ì—¬ê¸°ì—ëŠ” dandy_tops.pkl ë“± ì €ì¥ë˜ì–´ ìˆìŒ) ===
EMBEDDING_DIR = "./embeddings_by_style"

# === ê° ìŠ¤íƒ€ì¼ë³„ í¬í•¨ ì¹´í…Œê³ ë¦¬ ì •ì˜ ===
STYLE_CATEGORIES = {
    "lovely": ["tops", "bottoms", "setup"],
    "dandy": ["tops", "bottoms"],
    "street": ["tops", "bottoms"],
    "casual": ["tops", "bottoms"],
    "sporty": ["tops", "bottoms"],
    "vintage": ["tops", "bottoms"],
}

# === ë°ì´í„° ëª¨ë¸ ì •ì˜ (Pydantic) ===
class FavoriteItem(BaseModel):
    name: str
    style: str
    embedding: List[float]

class UserInput(BaseModel):
    style: str
    category: str
    season: str
    situation: str

class RecommendRequest(BaseModel):
    email : str  # ìœ ì € ID ì¶”ê°€ (Firestore ì €ì¥ì— í•„ìš”)
    user_input: UserInput
    favorites: List[FavoriteItem] = []

# === ìŠ¤íƒ€ì¼ì— ë§ëŠ” ì˜ìƒ ì•„ì´í…œ ë¶ˆëŸ¬ì˜¤ê¸° ===
def load_items(style, category=None):
    items = []
    categories = STYLE_CATEGORIES.get(style, [])
    target_categories = [category] if category else categories
    for cat in target_categories:
        filename = f"{style}_{cat}.pkl"
        filepath = os.path.join(EMBEDDING_DIR, filename)
        if os.path.exists(filepath):
            items += joblib.load(filepath)
    return items

# === ì¦ê²¨ì°¾ê¸° ê¸°ë°˜ ì¶”ì²œ (ìŠ¤íƒ€ì¼ì´ ì¼ì¹˜í•  ë•Œë§Œ ì‚¬ìš©ë¨) ===
def recommend_by_favorites(favorites, style):
    fav_names = [fav['name'] for fav in favorites]
    fav_embeddings = model.encode(fav_names, convert_to_tensor=True)
    same_style_items = load_items(style)
    if not same_style_items:
        return []
    item_embeddings = [item['embedding'] for item in same_style_items]
    sim_scores = []
    for i, emb in enumerate(item_embeddings):
        sim = sum([util.cos_sim(emb, fav_emb).item() for fav_emb in fav_embeddings]) / len(fav_embeddings)
        sim_scores.append((same_style_items[i], sim))
    sorted_items = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    return [item[0] for item in sorted_items[:5]]

# === ë¬´ì‘ìœ„ ì¶”ì²œ (ì¦ê²¨ì°¾ê¸° ì—†ê±°ë‚˜ ìŠ¤íƒ€ì¼ ë¶ˆì¼ì¹˜ ì‹œ ì‚¬ìš©ë¨) ===
def recommend_random(user_input, count=10):
    items = load_items(user_input['style'], user_input['category'])
    filtered = [
        item for item in items
        if item['season'] == user_input['season'] and
           item['situation'] == user_input['situation']
    ]
    return random.sample(filtered, min(len(filtered), count))

# === ìµœì¢… ì¶”ì²œ í•¨ìˆ˜: ì¡°ê±´ì— ë”°ë¼ ë°©ì‹ ì„ íƒ ===
def recommend(user_input, favorites):
    style = user_input['style']
    category = user_input['category']
    if len(favorites) >= 5 and all(fav['style'] == style for fav in favorites):
        fav_based = recommend_by_favorites(favorites, style)
        full_pool = load_items(style)
        remaining = [item for item in full_pool if item not in fav_based]
        rand_based = random.sample(remaining, min(5, len(remaining)))
        return fav_based + rand_based
    return recommend_random(user_input, count=10)



# === Firestore ì €ì¥ í•¨ìˆ˜ (results) ===
def save_to_firestore(email, user_input, recommendations):
    # users/{email}/results/ ë¬¸ì„œ ìƒì„±
    user_ref = db.collection("users").document(email)
    results_ref = user_ref.collection("results").document()
    results_ref.set({
        "title": user_input["category"],        # title í•„ë“œ ì¶”ê°€
        "style": user_input["style"],           # ìŠ¤íƒ€ì¼ ê·¸ëŒ€ë¡œ ì €ì¥
        "recommendations": recommendations      # 10ê°œ ìƒí’ˆ, ì„ë² ë”© í¬í•¨
    })


# === FastAPI POST ì—”ë“œí¬ì¸íŠ¸ (/recommend) ===
@app.post("/recommend")
async def get_recommendation(
    data: RecommendRequest,
    x_api_key: str = Header(...)  #  API í‚¤ë¥¼ í—¤ë”ì—ì„œ ë°›ìŒ
):
    # ğŸ”’ API Key ê²€ì‚¬
    if x_api_key != API_KEY:
        raise HTTPException(status_code=403, detail="Invalid API Key")

    user_input_dict = data.user_input.dict()
    favorites_list = [fav.dict() for fav in data.favorites]
    recommendations = recommend(user_input_dict, favorites_list)

    # Firestore ì €ì¥
    save_to_firestore(data.email, user_input_dict, recommendations)

    return {"recommendations": recommendations}


from fastapi import Request


# === ì¦ê²¨ì°¾ê¸° ì¶”ê°€ ===
@app.post("/bookmarks/add")
async def add_bookmark(request: Request):
    data = await request.json()
    email = data.get("email")
    title = data.get("title")
    style = data.get("style")

    if not email or not title or not style:
        raise HTTPException(status_code=400, detail="Missing required fields: email, title, or style")

    user_ref = db.collection("users").document(email)
    bookmarks_ref = user_ref.collection("bookmarks")

    # ì¤‘ë³µ ì €ì¥ ë°©ì§€
    existing = bookmarks_ref.where("title", "==", title).stream()
    if any(existing):
        return {"result": "already exists", "title": title}

    bookmarks_ref.add({
        "email": email,
        "title": title,
        "style": style
    })

    return {"result": "added", "title": title}


# === ì¦ê²¨ì°¾ê¸° ì‚­ì œ ===
@app.post("/bookmarks/delete")
async def delete_bookmark(request: Request):
    data = await request.json()
    email = data.get("email")
    title = data.get("title")

    if not email or not title:
        raise HTTPException(status_code=400, detail="Missing required fields: email or title")

    bookmarks_ref = db.collection("users").document(email).collection("bookmarks")
    bookmarks = bookmarks_ref.where("title", "==", title).stream()

    deleted = False
    for doc in bookmarks:
        bookmarks_ref.document(doc.id).delete()
        deleted = True

    if deleted:
        return {"result": "deleted", "title": title}
    else:
        raise HTTPException(status_code=404, detail="Bookmark not found")


# === ì¦ê²¨ì°¾ê¸° ì¡°íšŒ ===
@app.get("/bookmarks/{email}")
async def get_bookmarks(email: str):
    docs = db.collection("users").document(email).collection("bookmarks").stream()
    bookmarks = [{**doc.to_dict(), "id": doc.id} for doc in docs]
    return {"bookmarks": bookmarks}
